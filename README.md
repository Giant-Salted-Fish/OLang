### 关于 OLang

OLang 是我正在开发的一款实验性的通用编程语言，主要用来测试我对编程语言语法的各种构想，顺便探索下类型系统、生命周期管理、模板元编程等相关内容。目前 OLang 的大部分语法结构已经基本确定，但在不可变性表达、泛型参数约束、模块导入导出等方面仍在推敲和修改当中，未来可能会有较大变化。OLang 当前主要使用 Python 3.13 开发，在安装好 Python 后即可运行项目中的 [`main.py`](/main.py) 脚本来编译和运行 [`test.olang`](/test.olang) 中的 OLang 测试代码。OLang 的语法规范详见 [`lang_spec.py`](/lang_spec.py)；解析 OLang 源码所使用的 LR(1) Parser 实现代码参见 [`parser.py`](/parser.py)。

### 语法介绍

OLang 的语法设计主要借鉴了 [Zig](https://ziglang.org/)，[Rust](https://www.rust-lang.org/)，[Haskell](https://www.haskell.org/) 这几门语言，其目标是在维持一致性与简洁性的同时尽可能地提高语言的表达能力与可扩展性。

#### 变量

OLang 中的变量使用 `let` 关键字声明，可以在变量名后使用冒号注解其能够接受的类型。变量声明目前暂不支持指定不可变性，关于这个方面计划在未来斟酌后添加相应的语法，目前主要考虑 Rust 中 `mut` 关键字或是 Zig 中 `const` 关键字的形式。下面是一些符合 OLang 语法的变量声明示例：

```
let v1: bool;  // 声明一个 v1 变量并标注其类型为 bool
let v2 = 100;  // 声明一个 v2 变量并初始化为 100
let v3, v4: i32, v5 = "hello", 14, TRUE;  // 可以一次性声明多个变量
```

#### 字面量类型

OLang 目前内置的字面量类型包括 `i32`，`bool` 和 `str`，这些字面量类型的默认都是不可变的，可以用下面的语法创建对应类型的值：

```
let v1 = 2345;  // 整数字面量
let v2, v3 = TRUE, FALSE;  // 布尔字面量
let v4 = "Hello, world!";  // 字符串字面量
```

#### 结构化类型

OLang 为元组和结构体这两种编程中常用的结构化数据类型提供了原生语法支持，要在 OLang 中创建元组可以使用如下示例语法：

```
let tup1 = ();  // 创建一个空元组
let tup2 = 5,;  // 如果元组只有一个元素，则末尾的逗号不能省略
let tup3 = 1, 3, 5;  // 多个元素的元组，末尾的逗号可有可无
let tup3 = (2, 4, 6);  // 当然如果你想的话也可以在元组两侧添加括号
```

OLang 的结构体语法相比其它语言稍有不同，字段声明使用的是 `let` 表达式：

```
let stct = .(
    let fld1 = 5;
    let fld2 = "Hello, world!";
    let fld3 = TRUE  // 最后一个字段后可以省略分号
);
```

OLang 对使用 `.( )` 创建的结构体是有特殊照顾的，其字段声明语句中的 `let` 关键字可以省略，末尾的分号也可以替换成逗号，所以下面这种写法和上面是一样的：

```
let stct = .(fld1 = TRUE, fld2 = "Hello, world!", fld3 = 5);

// 混搭也是可以的，但并不推荐
let mixed = .(
    let fld1 = 5,
    fld2 = "Hello, world!";
    fld3 = TRUE,
);
```

除了上述语法之外 OLang 还提供了使用 `.{ }` 声明的代码块结构体语法，它和后文会介绍的[代码块](#代码块)相比的主要区别在：

1. 代码块结构体中的 `let` 表达式对应的是字段声明；
2. 代码块结构体的求值结果是一个包含了这些声明字段的结构体。

下面是一个具体的示例，注意代码块结构体没有语法特殊照顾，所以不能省略 let 或是替换分号：

```
let stct = .{
    let fld1 = 5;
    print(fld1 + 7);  // 除了字段声明外还可以插入别的语句
    let fld2 = "Hello, world!";
    let fld3 = TRUE
};
```

除此之外，OLang 还提供了 `tuple` 和 `struct` 关键字，用于声明带有具体名称的元组和结构体类型：

```
// 创建一个名为 Point2D 的具名元组类型
tuple Point2D (i32, i32)  // 声明末尾的分号可以省略
let val1: Point2D = Point2D(3, 5);

// 创建一个名为 Point3D 的具名结构体类型
struct Point3D .(
    let x = i32;
    let y = i32;
    let z = i32
)
let val2: Point3D = Point3D.(x = 3, y = 5, z = 7);
```

#### 解构赋值

OLang 也支持 JS、Rust、Zig 等语言中常见的解构赋值，它可以用来便捷地展开结构化的数据。OLang 的解构赋值语法遵循一条简单的规则，只要将创建结构化数据时填入值的位置替换成想要的变量名即可。

下面是一些 OLang 中解构赋值的示例：

```
// 解构元组，得到变量 a = 5, b = "Hello", c = TRUE
let a, b: str, c = (5, "Hello", TRUE);  // 

// 解构结构体，得到变量 a = 5, b = 7
let .(let foo = d, let bar = e) = .{
    let foo = 5;
    let bar = 7
};

// 使用解构重新赋值
a, b, c = 13, "World", FALSE;

// 甚至可以混搭，但并不推荐
(let f), a, (let g) = "Yes", 7, "No";
```

请注意在 OLang 中逗号运算符的结合优先级比等号运算符更高，这种设计是 OLang 语法上仔细斟酌后的取舍，它的好处是让我们在编写解构赋值时不用写成下面这样：

```
(a, b, c) = (1, 3, 5);  // 省略两边的括号会让整条语句变成一个元组表达式
```

它的不好的地方是会让下面这种代码变得很有迷惑性：

```
a = 3, b = 5, c = 7;  // 这行代码做了什么？
```

这行代码看起来像是一连串的赋值，但根据前文提到的优先级关系，它实际上等价于下面这种写法：

```
a = (3, b) = (5, c) = 7;
```

如果要在一行内赋值多个变量建议优先使用解构赋值；如果非要使用前面的写法请在合适的位置添加括号：

```
a, b, c = 3, 5, 7;  // 直接使用解构赋值
(a = 3), (b = 5), (c = 7);  // 使用括号改变结合顺序
```

#### 代码块

OLang 中可以使用一对大括号建立代码块，块中的语句使用分号分隔，当程序运行到代码块时会顺序执行其中语句。代码块的求值结果是其中最后一条被执行语句的值，对空代码块求值将返回空元组：

```
let result = {
    let a = 3;
    let b = 5;
    a + b;  // 这里的结果会被赋给 result
};
```

下面这种写可能会有些迷惑性：

```
let tup = { 1, 3, 5 };
```

等号的右边看起来很像 C 中的数组或是 Python 中的集合，但它其实是只有一条语句的代码块，这条语句创建了一个元组，其后的分号被省略了。

#### 函数

OLang 中的函数可以通过 `fn` 关键字定义：

```
// 创建一个名为 foo 的函数
fn foo(x: i32, y: i32) {
    x + y
}

// 调用定义好的 foo 函数
let result = foo(3, 5);
```

需要注意的是 OLang 中的函数只能有一个参数和返回值，所以上述示例中的 `foo` 函数其实是一个接收 `(i32, i32)` 类型参数的函数。为了更清晰地展示这其中的区别，我们可以将它改成如下等价形式：

```
fn foo (pair: (i32, i32)) {
    let x, y = pair;
    x + y
}
```

OLang 函数的形参声明实际上等同于前文介绍过的[解构赋值](#解构赋值)表达式的左侧，它会将函数调用时接收到的实参解构到当前的上下文中供函数体执行使用。对应的，`foo(3, 5)` 这种写法其实是先创建了元组 `(3, 5)`，然后再将其传递给 `foo` 函数进行函数调用。不过与很多其它编程语言不同的是，OLang 代码中的括号基本只用作改变代码语法元素的结合顺序，函数调用在没有歧义的情况下可以省略实参两侧的括号：

```
let args = 3, 5;
let result = foo args;  // 调用 foo 函数
```

特别地，因为函数调用的结合优先级比逗号运算符高，所以 `foo 3, 5` 这种写法实际上等同于 `(foo(3), 5)`，其结果是一个元组。

另外因为 OLang 的语法设计，下面这两个函数所接受的参数类型并不等价：

```
fn foo(val: i32) { val } // 该函数的参数类型为基本类型 i32
fn bar(val: i32,) { val } // 该函数的参数类型为元组类型 (i32,)
```

#### 模板

`待续...`

#### 匿名元素

`待续...`

#### 控制流

`待续...`

#### 注解

`待续...`

### 语义分析

`待实现...`

### 未来的规划（大饼/妄想）

- 设计所有权语法，移除 GC；
- 添加语义检查；
- 支持模板参数推导；
- 完成 OLang 编译器前端部分的自举；
- 提供类似 Zig 那种的元编程宏；
- 实现类似 Zig 的编译时惰性分析；
- 支持 C ABI 交互。
